

{
    "success": true,
    "data": {
        "status": true,
        "message": "SUCCESS",
        "errorcode": "",
        "data": {
            "script": "GAIL-EQ",
            "orderid": "1022aef9097cAO",
            "uniqueorderid": "9eb52af2-32b3-4101-9307-8d29399f659e"
        }
    }
}

//order

{
    "tradingsymbol": "GAIL-EQ",//o //p
    "symboltoken": "4717",//o //p
    "transactiontype": "BUY",//o
    "exchange": "NSE",//o //p
    "ordertype": "LIMIT",//o
    "producttype": "DELIVERY",//o //p
    "variety": "NORMAL",//o //p
    "duration": "DAY",//o //p
    "price": 170.5,//o 
    "quantity": 1
}


//modify
{
    "orderid": "101280dd2ef0AO",//o //p
    "tradingsymbol": "GAIL-EQ",//o //p
    "symboltoken": "4717",//o //p
    "exchange": "NSE",//o //p
    "ordertype": "LIMIT",//o
    "producttype": "DELIVERY",//o //p
    "duration": "DAY",//o //p
    "price": 2467.5,//o
    "quantity": 2,//o //p
    "variety": "NORMAL"//o //p
}

//tick

{
    "subscription_mode": "1",
    "exchange_type": "2",
    "token": "116750",//p
    "sequence_number": "28019",
    "exchange_timestamp":"1761096308775",
    "last_traded_price": "585"//p
  }

  //sell
  {
    "tradingsymbol": "SENSEX25O1685000CE",
    "symboltoken": "876189",
    "exchange": "BFO",
    "producttype": "INTRADAY",
    "quantity": 20
}



{
"tradingsymbol": "GAIL-EQ",//o //p
"orderid": "1022aef9097cAO",// null // id
"symboltoken": "4717",// id
"exchange":"BFO",//BFO //NFO //NS //BSE
"producttype": "DELIVERY",//DELIVERY // INTRADAY
"variety": "NORMAL",//o //p
"duration": "DAY",//o //p
"buy_price": 170.5,//o 
"quantity": 1,
"last_traded_price": 172,//p
"profit_loss":2700,
"higest_profit":2850,
"limit_sell_price":174,
"stop_loss":800, //800 //1500
"trail":"50%", //50% //75% //cost //800 //1000
"trade_status":"running" //running/pending/closed/cancelled
}












// src/services/angelFeed.js
const { WebSocketV2 } = require("smartapi-javascript");
const WebSocket = require("ws");
const EventEmitter = require("events");

const feedEmitter = new EventEmitter();

// Global state
let marketWS = null;
let orderWS = null;
let isConnected = false;
let isFeedConnected = false;
let isSessionActive = false;
let reconnectTimer = null;
let listenersAttached = false;

// ðŸ”¹ Exchange Mapping
const exchangeMap = { NSE: 1, NFO: 2, BSE: 3, BFO: 4, MCX: 5 };

/**
 * Initialize Market Feed WebSocket
 */
async function initAngelFeed({ jwtToken, feedToken }) {
  const apiKey = process.env.ANGEL_ONE_API_KEY;
  const clientCode = process.env.ANGEL_ONE_USERNAME;

  if (!jwtToken || !feedToken)
    throw new Error("Missing jwtToken or feedToken for feed initialization");

  if (isConnected && marketWS) {
    console.log("âš™ï¸ Market feed already connected, skipping init.");
    return marketWS;
  }

  try {
    marketWS = new WebSocketV2({
      jwttoken: jwtToken,
      apikey: apiKey,
      clientcode: clientCode,
      feedtype: feedToken,
    });

    await marketWS.connect();
    isConnected = true;
    isFeedConnected = true;
    isSessionActive = true;

    console.log("ðŸ“¡ Market WebSocket connected âœ…");
    emitFeedStatus();

    attachMarketListeners(jwtToken, feedToken);

    // âœ… Initialize Order Status WebSocket
    initOrderStatusFeed(jwtToken, clientCode);

    return marketWS;
  } catch (err) {
    console.error("âŒ Failed to connect Angel One Market Feed:", err.message || err);
    isFeedConnected = false;
    emitFeedStatus();
    scheduleReconnect(jwtToken, feedToken);
  }
}

/**
 * Attach listeners for Market Feed
 */
function attachMarketListeners(jwtToken, feedToken) {
  if (!marketWS || listenersAttached) return;

  marketWS.on("tick", (data) => feedEmitter.emit("tick", data));

  marketWS.on("error", (err) => {
    console.error("âŒ Market feed error:", err.message || err);
    isFeedConnected = false;
    emitFeedStatus();
  });

  marketWS.on("close", () => {
    console.warn("ðŸ”Œ Market feed closed â€” retrying in 10s...");
    isConnected = false;
    isFeedConnected = false;
    emitFeedStatus();
    listenersAttached = false;
    scheduleReconnect(jwtToken, feedToken);
  });

  listenersAttached = true;
  console.log("ðŸŽ§ Market WebSocket listeners attached (tick)");
}

/**
 * âœ… Initialize the official Angel One Order Status WebSocket
 * Endpoint: wss://tns.angelone.in/smart-order-update
 */
function initOrderStatusFeed(jwtToken, clientCode) {
  const ORDER_FEED_URL = "wss://tns.angelone.in/smart-order-update";

  try {
    console.log("ðŸ“¦ Connecting to Angel One Order Status WebSocket...");

    orderWS = new WebSocket(ORDER_FEED_URL, {
      headers: {
        Authorization: `Bearer ${jwtToken}`,
      },
    });

    orderWS.on("open", () => {
      console.log("ðŸ“¦ Order Status WebSocket connected âœ…");
      // Send initial ping every 10s to keep the connection alive
      setInterval(() => {
        if (orderWS.readyState === WebSocket.OPEN) {
          orderWS.send(JSON.stringify({ ping: "ping" }));
        }
      }, 10000);
    });

    orderWS.on("message", (msg) => {
      try {
        // ðŸ§© 1ï¸âƒ£ Handle plain "pong" text from server
        if (msg === "pong" || msg.toString().trim() === "pong") {
          // Optional: console.log("ðŸ” Pong received (connection alive)");
          return;
        }
    
        // ðŸ§© 2ï¸âƒ£ Parse JSON messages only
        const data = JSON.parse(msg);
    
        // ðŸ§© 3ï¸âƒ£ Handle valid order update messages
        if (data["status-code"] === "200" && data.orderData) {
          const order = data.orderData;
          const statusCode = data["order-status"];
    
          const statusMap = {
            AB01: "open",
            AB02: "cancelled",
            AB03: "rejected",
            AB04: "modified",
            AB05: "complete",
            AB09: "pending",
            AB10: "trigger pending",
          };
    
          order.status = statusMap[statusCode] || order.status || "unknown";
    
          console.log(
            `ðŸ“¬ Order Update: ${order.tradingsymbol} (${order.orderid}) â†’ ${order.status}`
          );
    
          feedEmitter.emit("orderUpdate", order);
        }
      } catch (err) {
        console.error("âš ï¸ Error parsing order message:", err.message);
      }
    });

    orderWS.on("close", () => {
      console.warn("ðŸ§± Order Status WebSocket closed â€” reconnecting in 10s...");
      setTimeout(() => initOrderStatusFeed(jwtToken, clientCode), 10000);
    });

    orderWS.on("error", (err) => {
      console.error("âŒ Order Status WebSocket error:", err.message);
    });
  } catch (err) {
    console.error("âŒ Failed to connect Order Status Feed:", err.message || err);
  }
}

/**
 * Schedule reconnection for Market Feed
 */
function scheduleReconnect(jwtToken, feedToken, delay = 10000) {
  if (reconnectTimer) clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(
    () => reconnectFeed({ jwtToken, feedToken }),
    delay
  );
}

/**
 * Attempt reconnection
 */
async function reconnectFeed({ jwtToken, feedToken }) {
  try {
    console.log("â™»ï¸ Reconnecting to Market Feed...");
    await initAngelFeed({ jwtToken, feedToken });
  } catch (err) {
    console.error("âŒ Market feed reconnection failed:", err.message || err);
    scheduleReconnect(jwtToken, feedToken, 15000);
  }
}

/**
 * Subscribe to market tokens dynamically
 */
function subscribeTokens(tokens, exchangeType = "NFO", mode = 1) {
  if (!marketWS || !isConnected)
    return console.warn("âš ï¸ Market feed not ready yet. Cannot subscribe.");

  const exType =
    typeof exchangeType === "string"
      ? exchangeMap[exchangeType.toUpperCase()] || 1
      : exchangeType;

  const subReq = {
    correlationID: `sub_${Date.now()}`,
    action: 1,
    mode,
    exchangeType: exType,
    tokens: Array.isArray(tokens) ? tokens : [tokens],
  };

  try {
    marketWS.fetchData(subReq);
    console.log(`âœ… Subscribed to ${subReq.tokens.join(", ")} [${exchangeType} â†’ ${exType}]`);
  } catch (err) {
    console.error("âš ï¸ Subscription failed:", err.message || err);
  }
}

/**
 * Emit feed status
 */
function emitFeedStatus() {
  const status = { isFeedConnected, isSessionActive };
  feedEmitter.emit("feedStatus", status);
}

/**
 * Get current feed status
 */
function getFeedStatus() {
  return { isFeedConnected, isSessionActive };
}

/**
 * Toggle session status
 */
function setSessionStatus(status) {
  isSessionActive = Boolean(status);
  console.log(`ðŸ” Session active: ${isSessionActive}`);
  emitFeedStatus();
}

module.exports = {
  initAngelFeed,
  subscribeTokens,
  setSessionStatus,
  feedEmitter,
  getFeedStatus,
};









// server.js
const http = require("http");
const dotenv = require("dotenv");

const app = require("./src/app");
const { initTradeManager } = require("./src/tradeManager");
const {
  initAngelFeed,
  subscribeTokens,
  feedEmitter,
} = require("./src/services/angelFeed");
const { initSocketServer } = require("./src/services/socketServer");
const { autoLogin } = require("./src/controllers/authorizationController");

dotenv.config();

const PORT = process.env.PORT || 5050;
const server = http.createServer(app);

async function startServer() {
  try {
    // Start HTTP + Socket.IO
    server.listen(PORT, () => console.log(`ðŸš€ Traderobot running on port ${PORT}`));
    const io = initSocketServer(server);

    // Auto-login SmartAPI
    const loginData = await autoLogin();
    const { jwtToken, feedToken } = loginData?.data || {};
    if (!jwtToken || !feedToken)
      throw new Error("Missing SmartAPI tokens");

    console.log("âœ… SmartAPI Login Successful");

    // Initialize feeds
    await initAngelFeed({ jwtToken, feedToken });
    console.log("âœ… Angel One WebSockets Active");

    // Subscribe to test instrument
    subscribeTokens("116750", "NFO");

    // Initialize Trade Manager (auto logic)
    initTradeManager();

    // Forward all events to connected clients
    feedEmitter.on("tick", (tick) => io.emit("tick", tick));
    feedEmitter.on("feedStatus", (status) => io.emit("feedStatus", status));
    feedEmitter.on("orderUpdate", (order) => {
      console.log("ðŸ“¡ Broadcasting Order Update:", order.tradingsymbol, order.status);
      io.emit("orderUpdate", order);
    });

    console.log("ðŸ§  Traderobot backend fully initialized âœ…");
  } catch (err) {
    console.error("âŒ Server failed to start:", err.message || err);
    process.exit(1);
  }
}

startServer();



    // 8ï¸âƒ£ Listen for live ticks
    feedEmitter.on("tick", (tick) => {
        console.log("ðŸ“ˆ Tick received:", tick);
        // Example: you can broadcast ticks to all sockets
        io.emit("tick", tick);
      });
  
      // 9ï¸âƒ£ Listen for feed connection changes
      feedEmitter.on("feedStatus", (status) => {
        io.emit("feedStatus", status);
      });
  


      ðŸ“¦ Broadcasting orderUpdate: YESBANK-EQ â†’ open
orerUpdate {
  variety: 'NORMAL',
  ordertype: 'LIMIT',
  ordertag: '',
  producttype: 'INTRADAY',
  price: 22,
  triggerprice: 0,
  quantity: '1',
  disclosedquantity: '0',
  duration: 'DAY',
  squareoff: 0,
  stoploss: 0,
  trailingstoploss: 0,
  tradingsymbol: 'YESBANK-EQ',
  transactiontype: 'BUY',
  exchange: 'NSE',
  symboltoken: '11915',
  instrumenttype: '',
  strikeprice: -1,
  optiontype: '',
  expirydate: '',
  lotsize: '1',
  cancelsize: '0',
  averageprice: 0,
  filledshares: '0',
  unfilledshares: '1',
  orderid: '251024000433901',
  text: '',
  status: 'open',
  orderstatus: 'open',
  updatetime: '24-Oct-2025 11:38:22',
  exchtime: '24-Oct-2025 11:38:22',
  exchorderupdatetime: '24-Oct-2025 11:38:22',
  fillid: '',
  filltime: '',
  parentorderid: ''
}